package 代码块执行顺序;

import java.util.Scanner;

/*
	代码块的顺序问题          加载优先级：   静态成员变量 = 静态代码块 > 成员变量 = 构造代码块 > 构造方法      
	                                         但是静态成员对象和静态代码块只在类加载时加载一次，再次创建对象不会再次加载

	输出结果：
			我是测试类中的静态代码块
			a的值是：10
			这是主方法---a的值是：10
			c的值是：2
			b的值是：1
			--------------
			c的值是：2      
			b的值是：1
			--------------
			c的值是：2
			b的值是：1
			--------------
*/                          
            
class DeMo{
	
	static int a = 10;                           //这是静态成员变量
	
	static {                                    //这是静态代码块
												//在这里，如果静态代码块放在静态成员变量之前，则会报错（报错原因是a未赋值）
		System.out.println("a的值是："+a);		//这说明，静态代码块和静态成员变量的优先级是一样的，都是在类加载时加载（初始化且赋予地址值）
	}											//静态代码块加载的顺序按它们的先后顺序决定
	
	public DeMo(){                              //这是构造方法，创建对象时它的输出在构造代码块之后
		int b = 1;								//说明构造代码块的加载优先级大于构造方法
		System.out.println("b的值是："+b);      //并且构造代码块之间的加载顺序按他们的先后顺序决定
	}
	
	public static void q(){                     //这是静态方法
		int d = 3;								//主方法执行完毕后未输出过"d的值是：3"
		System.out.println("d的值是："+d);      //说明静态方法在加载时，不会像静态代码块和静态成员变量那样执行（初始化）
	}											//而是加载后放在静态方法区（赋予地址值）等待调用
	
	{                                           //这是构造代码块
		int c = 2;
		System.out.println("c的值是："+c);
	}
}

public class B{

	public static void main(String[] args){
		System.out.println("这是主方法---a的值是："+DeMo.a); /*调用静态成员变量并输出，发现先输出的是"a的值是：0",可见在
															执行这串代码时，先加载了类中所有的静态（代码块。成员变量），
															再调用a的值
															之后创建对象再也没出现"a的值是：0"，说明静态只加载一次
															*/
			
	
		DeMo d1 = new DeMo();                   //创造对象d1  
		System.out.println("--------------"); 
		
		DeMo d2 = new DeMo();                   //创造对象d2  
		System.out.println("--------------"); 
		
		DeMo d3 = new DeMo();                   //创造对象d3
		System.out.println("--------------");
		
		// DeMo.q();                          //调用静态方法，在调用后才会执行
	}

	static {
		System.out.println("我是测试类中的静态代码块");      //在命令行执行java B 时，先加载类B，然后执行此代码块，再然后才被JVM虚拟机调用main方法
	}
}